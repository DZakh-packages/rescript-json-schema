// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var JSONSchema7 = require("./JSONSchema7.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var S$RescriptStruct = require("rescript-struct/src/S.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var Exception = /* @__PURE__ */Caml_exceptions.create("JSONSchema.Error.Exception");

function raise(code) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          code: code,
          path: []
        },
        Error: new Error()
      };
}

function pathToText(path) {
  if (path.length !== 0) {
    return path.map(function (pathItem) {
                  return "[\"" + pathItem + "\"]";
                }).join("");
  } else {
    return "root";
  }
}

function prependLocation(error, $$location) {
  error.path = [$$location].concat(error.path);
  return error;
}

function toString(error) {
  var pathText = pathToText(error.path);
  var structName = error.code;
  var reason;
  if (typeof structName === "number") {
    reason = structName === /* UnsupportedNestedOptional */0 ? "Optional struct is not supported inside the Option struct" : "Optional struct is not supported at root";
  } else {
    switch (structName.TAG | 0) {
      case /* UnsupportedOptionalItem */0 :
          reason = "Optional struct is not supported as " + structName._0 + " item";
          break;
      case /* UnsupportedStruct */1 :
          reason = "The " + structName._0 + " struct is not supported";
          break;
      case /* DefaultDestructingFailed */2 :
          reason = "Couldn't destruct default value. Error: " + structName.destructingErrorMessage + "";
          break;
      
    }
  }
  return "[ReScript JSON Schema] Failed converting at " + pathText + ". Reason: " + reason + "";
}

var schemaExtendMetadataId = Curry._2(S$RescriptStruct.Metadata.Id.make, "rescript-json-schema", "schemaExtend");

function isOptionalStruct(struct) {
  var match = S$RescriptStruct.classify(struct);
  if (typeof match === "number" || match.TAG !== /* Option */1) {
    return false;
  } else {
    return true;
  }
}

function makeStructSchema(struct) {
  var schema = {};
  var childStruct = S$RescriptStruct.classify(struct);
  if (typeof childStruct === "number") {
    switch (childStruct) {
      case /* Never */0 :
          schema.not = {};
          break;
      case /* String */2 :
          schema.type = "string";
          S$RescriptStruct.$$String.refinements(struct).forEach(function (refinement) {
                var match = refinement.kind;
                if (typeof match === "number") {
                  switch (match) {
                    case /* Email */0 :
                        schema.format = "email";
                        return ;
                    case /* Uuid */1 :
                        schema.format = "uuid";
                        return ;
                    case /* Cuid */2 :
                        return ;
                    case /* Url */3 :
                        schema.format = "uri";
                        return ;
                    case /* Datetime */4 :
                        schema.format = "date-time";
                        return ;
                    
                  }
                } else {
                  switch (match.TAG | 0) {
                    case /* Min */0 :
                        schema.minLength = match.length;
                        return ;
                    case /* Max */1 :
                        schema.maxLength = match.length;
                        return ;
                    case /* Length */2 :
                        var length = match.length;
                        schema.minLength = length;
                        schema.maxLength = length;
                        return ;
                    case /* Pattern */3 :
                        schema.pattern = String(match.re);
                        return ;
                    
                  }
                }
              });
          break;
      case /* Int */3 :
          schema.type = "integer";
          S$RescriptStruct.Int.refinements(struct).forEach(function (refinement) {
                var match = refinement.kind;
                if (typeof match === "number") {
                  return ;
                } else {
                  if (match.TAG === /* Min */0) {
                    schema.minimum = match.value;
                  } else {
                    schema.maximum = match.value;
                  }
                  return ;
                }
              });
          break;
      case /* Float */4 :
          schema.type = "number";
          S$RescriptStruct.Float.refinements(struct).forEach(function (refinement) {
                var match = refinement.kind;
                if (match.TAG === /* Min */0) {
                  schema.minimum = match.value;
                } else {
                  schema.maximum = match.value;
                }
              });
          break;
      case /* Bool */5 :
          schema.type = "boolean";
          break;
      case /* Unknown */1 :
      case /* JSON */6 :
          break;
      
    }
  } else {
    switch (childStruct.TAG | 0) {
      case /* Literal */0 :
          var value = childStruct._0;
          if (typeof value === "number") {
            switch (value) {
              case /* EmptyNull */0 :
                  schema.type = "null";
                  break;
              case /* EmptyOption */1 :
              case /* NaN */2 :
                  raise({
                        TAG: /* UnsupportedStruct */1,
                        _0: S$RescriptStruct.name(struct)
                      });
                  break;
              
            }
          } else {
            switch (value.TAG | 0) {
              case /* String */0 :
                  schema.type = "string";
                  schema.const = Caml_option.some(value._0);
                  break;
              case /* Int */1 :
                  schema.type = "integer";
                  schema.const = Caml_option.some(value._0);
                  break;
              case /* Float */2 :
                  schema.type = "number";
                  schema.const = Caml_option.some(value._0);
                  break;
              case /* Bool */3 :
                  schema.type = "boolean";
                  schema.const = Caml_option.some(value._0);
                  break;
              
            }
          }
          break;
      case /* Option */1 :
          var childStruct$1 = childStruct._0;
          if (isOptionalStruct(childStruct$1)) {
            raise(/* UnsupportedNestedOptional */0);
          }
          var childSchema = makeStructSchema(childStruct$1);
          Object.assign(schema, childSchema);
          var defaultValue = S$RescriptStruct.Default.classify(struct);
          if (defaultValue !== undefined) {
            var destructingError = S$RescriptStruct.serializeWith(Caml_option.some(Caml_option.valFromOption(defaultValue)), childStruct$1);
            if (destructingError.TAG === /* Ok */0) {
              schema.default = Caml_option.some(destructingError._0);
            } else {
              raise({
                    TAG: /* DefaultDestructingFailed */2,
                    destructingErrorMessage: S$RescriptStruct.$$Error.toString(destructingError._0)
                  });
            }
          }
          break;
      case /* Null */2 :
          schema.anyOf = [
            makeStructSchema(childStruct._0),
            {
              type: "null"
            }
          ];
          break;
      case /* Array */3 :
          var childStruct$2 = childStruct._0;
          if (isOptionalStruct(childStruct$2)) {
            raise({
                  TAG: /* UnsupportedOptionalItem */0,
                  _0: S$RescriptStruct.name(struct)
                });
          }
          schema.items = Caml_option.some(makeStructSchema(childStruct$2));
          schema.type = "array";
          S$RescriptStruct.$$Array.refinements(struct).forEach(function (refinement) {
                var match = refinement.kind;
                switch (match.TAG | 0) {
                  case /* Min */0 :
                      schema.minItems = match.length;
                      return ;
                  case /* Max */1 :
                      schema.maxItems = match.length;
                      return ;
                  case /* Length */2 :
                      var length = match.length;
                      schema.maxItems = length;
                      schema.minItems = length;
                      return ;
                  
                }
              });
          break;
      case /* Object */4 :
          var fields = childStruct.fields;
          var properties = {};
          var required = [];
          childStruct.fieldNames.forEach(function (fieldName) {
                var fieldStruct = fields[fieldName];
                var fieldSchema;
                try {
                  fieldSchema = makeStructSchema(fieldStruct);
                }
                catch (raw_error){
                  var error = Caml_js_exceptions.internalToOCamlException(raw_error);
                  if (error.RE_EXN_ID === Exception) {
                    throw {
                          RE_EXN_ID: Exception,
                          _1: prependLocation(error._1, fieldName),
                          Error: new Error()
                        };
                  }
                  throw error;
                }
                if (!isOptionalStruct(fieldStruct)) {
                  required.push(fieldName);
                }
                properties[fieldName] = fieldSchema;
              });
          var match = Curry._1(S$RescriptStruct.$$Object.UnknownKeys.classify, struct);
          var additionalProperties = match ? true : false;
          schema.type = "object";
          schema.properties = Caml_option.some(properties);
          schema.additionalProperties = Caml_option.some(additionalProperties);
          if (required.length !== 0) {
            schema.required = required;
          }
          break;
      case /* Tuple */5 :
          var items = childStruct._0.map(function (childStruct, idx) {
                try {
                  if (isOptionalStruct(childStruct)) {
                    return raise({
                                TAG: /* UnsupportedOptionalItem */0,
                                _0: S$RescriptStruct.name(struct)
                              });
                  } else {
                    return makeStructSchema(childStruct);
                  }
                }
                catch (raw_error){
                  var error = Caml_js_exceptions.internalToOCamlException(raw_error);
                  if (error.RE_EXN_ID === Exception) {
                    throw {
                          RE_EXN_ID: Exception,
                          _1: prependLocation(error._1, idx.toString()),
                          Error: new Error()
                        };
                  }
                  throw error;
                }
              });
          var itemsNumber = items.length;
          schema.items = Caml_option.some(items);
          schema.type = "array";
          schema.minItems = itemsNumber;
          schema.maxItems = itemsNumber;
          break;
      case /* Union */6 :
          var items$1 = childStruct._0.map(function (childStruct) {
                if (isOptionalStruct(childStruct)) {
                  return raise({
                              TAG: /* UnsupportedOptionalItem */0,
                              _0: S$RescriptStruct.name(struct)
                            });
                } else {
                  return makeStructSchema(childStruct);
                }
              });
          schema.anyOf = items$1;
          break;
      case /* Dict */7 :
          var childStruct$3 = childStruct._0;
          if (isOptionalStruct(childStruct$3)) {
            raise({
                  TAG: /* UnsupportedOptionalItem */0,
                  _0: S$RescriptStruct.name(struct)
                });
          }
          schema.type = "object";
          schema.additionalProperties = Caml_option.some(makeStructSchema(childStruct$3));
          break;
      
    }
  }
  var message = S$RescriptStruct.deprecation(struct);
  if (message !== undefined) {
    Object.assign(schema, {
          deprecated: true,
          description: message
        });
  }
  var m = S$RescriptStruct.description(struct);
  if (m !== undefined) {
    schema.description = m;
  }
  var metadataRawSchema = S$RescriptStruct.Metadata.get(struct, schemaExtendMetadataId);
  if (metadataRawSchema !== undefined) {
    Object.assign(schema, metadataRawSchema);
  }
  return schema;
}

function make(struct) {
  try {
    if (isOptionalStruct(struct)) {
      return raise(/* UnsupportedRootOptional */1);
    }
    var schema = makeStructSchema(struct);
    schema.$schema = "http://json-schema.org/draft-07/schema#";
    return {
            TAG: /* Ok */0,
            _0: schema
          };
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toString(error._1)
            };
    }
    throw error;
  }
}

function extend(struct, schema) {
  var existingSchemaExtend = S$RescriptStruct.Metadata.get(struct, schemaExtendMetadataId);
  return S$RescriptStruct.Metadata.set(struct, schemaExtendMetadataId, existingSchemaExtend !== undefined ? Object.assign({}, existingSchemaExtend, schema) : schema);
}

function primitiveToStruct(primitive) {
  var s = Js_json.classify(primitive);
  if (typeof s === "number") {
    switch (s) {
      case /* JSONFalse */0 :
          return S$RescriptStruct.literal({
                      TAG: /* Bool */3,
                      _0: false
                    });
      case /* JSONTrue */1 :
          return S$RescriptStruct.literal({
                      TAG: /* Bool */3,
                      _0: true
                    });
      case /* JSONNull */2 :
          return S$RescriptStruct.literal(/* EmptyNull */0);
      
    }
  } else {
    switch (s.TAG | 0) {
      case /* JSONString */0 :
          return S$RescriptStruct.literal({
                      TAG: /* String */0,
                      _0: s._0
                    });
      case /* JSONNumber */1 :
          var n = s._0;
          if (n < 2147483648 && n > -2147483649 && n % 1 === 0) {
            return S$RescriptStruct.literal({
                        TAG: /* Int */1,
                        _0: n
                      });
          } else {
            return S$RescriptStruct.literal({
                        TAG: /* Float */2,
                        _0: n
                      });
          }
      case /* JSONObject */2 :
          var d = s._0;
          return S$RescriptStruct.object(function (o) {
                      return Js_dict.fromArray(Js_dict.entries(d).map(function (param) {
                                      var key = param[0];
                                      return [
                                              key,
                                              S$RescriptStruct.field(o, key, primitiveToStruct(param[1]))
                                            ];
                                    }));
                    });
      case /* JSONArray */3 :
          return S$RescriptStruct.Tuple.factory(s._0.map(primitiveToStruct));
      
    }
  }
}

function toIntStruct(schema) {
  var struct = S$RescriptStruct.$$int(undefined);
  var minimum = schema.minimum;
  var struct$1;
  if (minimum !== undefined) {
    struct$1 = S$RescriptStruct.Int.min(struct, undefined, minimum | 0);
  } else {
    var exclusiveMinimum = schema.exclusiveMinimum;
    struct$1 = exclusiveMinimum !== undefined ? S$RescriptStruct.Int.min(struct, undefined, exclusiveMinimum + 1 | 0) : struct;
  }
  var maximum = schema.maximum;
  if (maximum !== undefined) {
    return S$RescriptStruct.Int.max(struct$1, undefined, maximum | 0);
  }
  var exclusiveMinimum$1 = schema.exclusiveMinimum;
  if (exclusiveMinimum$1 !== undefined) {
    return S$RescriptStruct.Int.max(struct$1, undefined, exclusiveMinimum$1 - 1 | 0);
  } else {
    return struct$1;
  }
}

function toStruct(schema) {
  var definitionToStruct = function (definition) {
    var s = JSONSchema7.Definition.classify(definition);
    if (s.TAG === /* Schema */0) {
      return toStruct(s._0);
    } else {
      return S$RescriptStruct.jsonable(undefined);
    }
  };
  var type_ = schema.type;
  var struct;
  var exit = 0;
  var exit$1 = 0;
  if (schema.nullable) {
    struct = S$RescriptStruct.$$null(toStruct(Object.assign({}, schema, {
                  nullable: false
                })));
  } else if (type_ !== undefined) {
    var type_$1 = Caml_option.valFromOption(type_);
    if (type_$1 === "object") {
      var properties = schema.properties;
      if (properties !== undefined) {
        var properties$1 = Caml_option.valFromOption(properties);
        var struct$1 = S$RescriptStruct.object(function (o) {
              return Js_dict.fromArray(Js_dict.entries(properties$1).map(function (param) {
                              var key = param[0];
                              var propertyStruct = definitionToStruct(param[1]);
                              var r = schema.required;
                              var propertyStruct$1 = r !== undefined && r.includes(key) ? propertyStruct : S$RescriptStruct.option(propertyStruct);
                              return [
                                      key,
                                      S$RescriptStruct.field(o, key, propertyStruct$1)
                                    ];
                            }));
            });
        var additionalProperties = schema.additionalProperties;
        struct = additionalProperties !== undefined && Caml_option.valFromOption(additionalProperties) === false ? S$RescriptStruct.$$Object.strict(struct$1) : struct$1;
      } else {
        var additionalProperties$1 = schema.additionalProperties;
        if (additionalProperties$1 !== undefined) {
          var s = JSONSchema7.Definition.classify(Caml_option.valFromOption(additionalProperties$1));
          struct = s.TAG === /* Schema */0 ? S$RescriptStruct.dict(toStruct(s._0)) : (
              s._0 ? S$RescriptStruct.dict(S$RescriptStruct.jsonable(undefined)) : S$RescriptStruct.$$Object.strict(S$RescriptStruct.object(function (param) {
                          
                        }))
            );
        } else {
          struct = S$RescriptStruct.object(function (param) {
                
              });
        }
      }
    } else if (type_$1 === "array") {
      var items = schema.items;
      var struct$2;
      if (items !== undefined) {
        var single = JSONSchema7.Arrayable.classify(Caml_option.valFromOption(items));
        struct$2 = single.TAG === /* Single */0 ? S$RescriptStruct.array(definitionToStruct(single._0)) : S$RescriptStruct.Tuple.factory(single._0.map(definitionToStruct));
      } else {
        struct$2 = S$RescriptStruct.array(S$RescriptStruct.jsonable(undefined));
      }
      var min = schema.minItems;
      var struct$3 = min !== undefined ? S$RescriptStruct.$$Array.min(struct$2, undefined, min) : struct$2;
      var max = schema.maxItems;
      struct = max !== undefined ? S$RescriptStruct.$$Array.max(struct$3, undefined, max) : struct$3;
    } else {
      exit$1 = 2;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    var primitives = schema.enum;
    var definitions = schema.allOf;
    var definitions$1 = schema.anyOf;
    if (definitions$1 !== undefined) {
      var len = definitions$1.length;
      struct = len !== 1 ? (
          len !== 0 ? S$RescriptStruct.union(definitions$1.map(definitionToStruct)) : S$RescriptStruct.jsonable(undefined)
        ) : definitionToStruct(definitions$1[0]);
    } else if (definitions !== undefined) {
      var len$1 = definitions.length;
      if (len$1 !== 1) {
        if (len$1 !== 0) {
          var refiner = function (data) {
            definitions.forEach(function (d) {
                  var match = S$RescriptStruct.parseWith(data, definitionToStruct(d));
                  if (match.TAG === /* Ok */0) {
                    return ;
                  } else {
                    return S$RescriptStruct.fail(undefined, "Should pass for all schemas of the allOf property.");
                  }
                });
          };
          struct = S$RescriptStruct.refine(S$RescriptStruct.jsonable(undefined), refiner, undefined, refiner, undefined);
        } else {
          struct = S$RescriptStruct.jsonable(undefined);
        }
      } else {
        struct = definitionToStruct(definitions[0]);
      }
    } else {
      var definitions$2 = schema.oneOf;
      if (definitions$2 !== undefined) {
        var len$2 = definitions$2.length;
        if (len$2 !== 1) {
          if (len$2 !== 0) {
            var refiner$1 = function (data) {
              var hasOneValidRef = {
                contents: false
              };
              definitions$2.forEach(function (d) {
                    var match = S$RescriptStruct.parseWith(data, definitionToStruct(d));
                    if (match.TAG === /* Ok */0) {
                      if (hasOneValidRef.contents) {
                        return S$RescriptStruct.fail(undefined, "Should pass single schema according to the oneOf property.");
                      } else {
                        hasOneValidRef.contents = true;
                        return ;
                      }
                    }
                    
                  });
              if (!hasOneValidRef.contents) {
                return S$RescriptStruct.fail(undefined, "Should pass at least one schema according to the oneOf property.");
              }
              
            };
            struct = S$RescriptStruct.refine(S$RescriptStruct.jsonable(undefined), refiner$1, undefined, refiner$1, undefined);
          } else {
            struct = S$RescriptStruct.jsonable(undefined);
          }
        } else {
          struct = definitionToStruct(definitions$2[0]);
        }
      } else {
        var not = schema.not;
        if (not !== undefined) {
          var not$1 = Caml_option.valFromOption(not);
          var refiner$2 = function (data) {
            var match = S$RescriptStruct.parseWith(data, definitionToStruct(not$1));
            if (match.TAG === /* Ok */0) {
              return S$RescriptStruct.fail(undefined, "Should NOT be valid against schema in the not property.");
            }
            
          };
          struct = S$RescriptStruct.refine(S$RescriptStruct.jsonable(undefined), refiner$2, undefined, refiner$2, undefined);
        } else if (primitives !== undefined) {
          var len$3 = primitives.length;
          struct = len$3 !== 1 ? (
              len$3 !== 0 ? S$RescriptStruct.union(primitives.map(primitiveToStruct)) : S$RescriptStruct.jsonable(undefined)
            ) : primitiveToStruct(primitives[0]);
        } else {
          var $$const = schema.const;
          if ($$const !== undefined) {
            struct = primitiveToStruct(Caml_option.valFromOption($$const));
          } else if (type_ !== undefined) {
            var match = schema.multipleOf;
            var type_$2 = Caml_option.valFromOption(type_);
            var exit$2 = 0;
            var exit$3 = 0;
            var match$1 = schema.format;
            if (JSONSchema7.Arrayable.isArray(type_$2)) {
              struct = S$RescriptStruct.union(type_$2.map(function (type_) {
                        return toStruct(Object.assign({}, schema, {
                                        type: Caml_option.some(type_)
                                      }));
                      }));
            } else if (type_$2 === "string") {
              var struct$4 = S$RescriptStruct.string(undefined);
              var pattern = schema.pattern;
              var struct$5 = pattern !== undefined ? S$RescriptStruct.$$String.pattern(struct$4, undefined, new RegExp(pattern)) : struct$4;
              var minLength = schema.minLength;
              var struct$6 = minLength !== undefined ? S$RescriptStruct.$$String.min(struct$5, undefined, minLength) : struct$5;
              var maxLength = schema.maxLength;
              var struct$7 = maxLength !== undefined ? S$RescriptStruct.$$String.max(struct$6, undefined, maxLength) : struct$6;
              var match$2 = schema.format;
              if (match$2 !== undefined) {
                switch (match$2) {
                  case "date-time" :
                      struct = S$RescriptStruct.$$String.datetime(struct$7, undefined, undefined);
                      break;
                  case "email" :
                      struct = S$RescriptStruct.$$String.email(struct$7, undefined, undefined);
                      break;
                  case "uri" :
                      struct = S$RescriptStruct.$$String.url(struct$7, undefined, undefined);
                      break;
                  case "uuid" :
                      struct = S$RescriptStruct.$$String.uuid(struct$7, undefined, undefined);
                      break;
                  default:
                    struct = struct$7;
                }
              } else {
                struct = struct$7;
              }
            } else if (type_$2 === "integer" || match$1 !== undefined && match$1 === "int64" && type_$2 === "number") {
              struct = toIntStruct(schema);
            } else {
              exit$3 = 4;
            }
            if (exit$3 === 4) {
              if (match !== undefined && !(match !== 1 || type_$2 !== "number")) {
                struct = toIntStruct(schema);
              } else {
                exit$2 = 3;
              }
            }
            if (exit$2 === 3) {
              if (type_$2 === "number") {
                var struct$8 = S$RescriptStruct.$$float(undefined);
                var minimum = schema.minimum;
                var struct$9;
                if (minimum !== undefined) {
                  struct$9 = S$RescriptStruct.Float.min(struct$8, undefined, minimum);
                } else {
                  var exclusiveMinimum = schema.exclusiveMinimum;
                  struct$9 = exclusiveMinimum !== undefined ? S$RescriptStruct.Float.min(struct$8, undefined, exclusiveMinimum + 1) : struct$8;
                }
                var maximum = schema.maximum;
                if (maximum !== undefined) {
                  struct = S$RescriptStruct.Float.max(struct$9, undefined, maximum);
                } else {
                  var exclusiveMinimum$1 = schema.exclusiveMinimum;
                  struct = exclusiveMinimum$1 !== undefined ? S$RescriptStruct.Float.max(struct$9, undefined, exclusiveMinimum$1 - 1) : struct$9;
                }
              } else if (type_$2 === "boolean") {
                struct = S$RescriptStruct.bool(undefined);
              } else if (type_$2 === "null") {
                struct = S$RescriptStruct.literal(/* EmptyNull */0);
              } else {
                exit = 1;
              }
            }
            
          } else {
            exit = 1;
          }
        }
      }
    }
  }
  if (exit === 1) {
    var if_ = schema.if;
    if (if_ !== undefined) {
      var then = schema.then;
      if (then !== undefined) {
        var else_ = schema.else;
        if (else_ !== undefined) {
          var ifStruct = definitionToStruct(Caml_option.valFromOption(if_));
          var thenStruct = definitionToStruct(Caml_option.valFromOption(then));
          var elseStruct = definitionToStruct(Caml_option.valFromOption(else_));
          var refiner$3 = function (data) {
            var match = S$RescriptStruct.parseWith(data, ifStruct);
            var result;
            result = match.TAG === /* Ok */0 ? S$RescriptStruct.parseWith(data, thenStruct) : S$RescriptStruct.parseWith(data, elseStruct);
            if (result.TAG === /* Ok */0) {
              return ;
            } else {
              return S$RescriptStruct.advancedFail(result._0);
            }
          };
          struct = S$RescriptStruct.refine(S$RescriptStruct.jsonable(undefined), refiner$3, undefined, refiner$3, undefined);
        } else {
          struct = S$RescriptStruct.jsonable(undefined);
        }
      } else {
        struct = S$RescriptStruct.jsonable(undefined);
      }
    } else {
      struct = S$RescriptStruct.jsonable(undefined);
    }
  }
  var description = schema.description;
  var struct$10 = description !== undefined ? S$RescriptStruct.describe(struct, description) : struct;
  var description$1 = schema.description;
  var struct$11 = description$1 !== undefined ? S$RescriptStruct.describe(struct$10, description$1) : struct$10;
  var $$default = schema.default;
  if ($$default === undefined) {
    return struct$11;
  }
  var $$default$1 = Caml_option.valFromOption($$default);
  return S$RescriptStruct.$$default(struct$11, (function (param) {
                return $$default$1;
              }));
}

function validate(schema) {
  var struct = toStruct(schema);
  return function (data) {
    var e = S$RescriptStruct.parseWith(data, struct);
    if (e.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: undefined
            };
    } else {
      return e;
    }
  };
}

var Arrayable = JSONSchema7.Arrayable;

var Mutable = JSONSchema7.Mutable;

var Definition = JSONSchema7.Definition;

var Dependency = JSONSchema7.Dependency;

exports.Arrayable = Arrayable;
exports.Mutable = Mutable;
exports.Definition = Definition;
exports.Dependency = Dependency;
exports.make = make;
exports.extend = extend;
exports.toStruct = toStruct;
exports.validate = validate;
/* schemaExtendMetadataId Not a pure module */
