// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var S$ReScriptStruct = require("rescript-struct/src/S.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var Exception = /* @__PURE__ */Caml_exceptions.create("JsonSchema.Error.Exception");

function raise(pathOpt, code) {
  var path = pathOpt !== undefined ? pathOpt : [];
  throw {
        RE_EXN_ID: Exception,
        _1: {
          code: code,
          path: path
        },
        Error: new Error()
      };
}

function raise$1(path, struct) {
  return raise(path, {
              TAG: /* UnsupportedOptionalItem */0,
              _0: S$ReScriptStruct.name(struct)
            });
}

function raise$2(path, struct) {
  return raise(path, {
              TAG: /* UnsupportedStruct */1,
              _0: S$ReScriptStruct.name(struct)
            });
}

function pathToText(path) {
  if (path.length !== 0) {
    return path.map(function (pathItem) {
                  return "[\"" + pathItem + "\"]";
                }).join("");
  } else {
    return "root";
  }
}

function prependLocation(error, $$location) {
  error.path = [$$location].concat(error.path);
  return error;
}

function toString(error) {
  var pathText = pathToText(error.path);
  var structName = error.code;
  var reason;
  if (typeof structName === "number") {
    reason = structName === /* UnsupportedNestedOptional */0 ? "Optional struct is not supported inside the Option struct" : "Optional struct is not supported at root";
  } else {
    switch (structName.TAG | 0) {
      case /* UnsupportedOptionalItem */0 :
          reason = "Optional struct is not supported as " + structName._0 + " item";
          break;
      case /* UnsupportedStruct */1 :
          reason = "The " + structName._0 + " struct is not supported";
          break;
      case /* DefaultDestructingFailed */2 :
          reason = "Couldn't destruct default value. Error: " + structName.destructingErrorMessage + "";
          break;
      
    }
  }
  return "[ReScript JSON Schema] Failed converting at " + pathText + ". Reason: " + reason + "";
}

function classify(arrayable) {
  if (Array.isArray(arrayable)) {
    return {
            TAG: /* Array */1,
            _0: arrayable
          };
  } else {
    return {
            TAG: /* Single */0,
            _0: arrayable
          };
  }
}

var Arrayable = {
  classify: classify
};

function classify$1(definition) {
  if (typeof definition === "boolean") {
    return {
            TAG: /* Boolean */1,
            _0: definition
          };
  } else {
    return {
            TAG: /* Schema */0,
            _0: definition
          };
  }
}

var Definition = {
  classify: classify$1
};

function classify$2(dependency) {
  if (Array.isArray(dependency)) {
    return {
            TAG: /* Required */1,
            _0: dependency
          };
  } else {
    return {
            TAG: /* Schema */0,
            _0: dependency
          };
  }
}

var Dependency = {
  classify: classify$2
};

function description(value) {
  return {
          description: value
        };
}

function $$default(value) {
  return {
          default: Caml_option.some(value)
        };
}

function schemaDialect(param) {
  return {
          $schema: "http://json-schema.org/draft-07/schema#"
        };
}

function string(param) {
  return {
          type: "string"
        };
}

function integer(param) {
  return {
          type: "integer"
        };
}

function number(param) {
  return {
          type: "number"
        };
}

function $$boolean(param) {
  return {
          type: "boolean"
        };
}

function $$null(childSchema) {
  return {
          anyOf: [
            childSchema,
            {
              type: "null"
            }
          ]
        };
}

function never(param) {
  return {
          not: {}
        };
}

function array(childSchema) {
  return {
          type: "array",
          items: Caml_option.some(childSchema)
        };
}

function tuple(items) {
  var itemsNumber = items.length;
  return {
          type: "array",
          items: Caml_option.some(items),
          maxItems: itemsNumber,
          minItems: itemsNumber
        };
}

function union(items) {
  return {
          anyOf: items
        };
}

function dict(childSchema) {
  return {
          type: "object",
          additionalProperties: Caml_option.some(childSchema)
        };
}

function record(properties, additionalProperties, required) {
  var schema_type = "object";
  var schema_properties = Caml_option.some(properties);
  var schema_additionalProperties = Caml_option.some(additionalProperties);
  var schema = {
    type: schema_type,
    properties: schema_properties,
    additionalProperties: schema_additionalProperties
  };
  if (required.length !== 0) {
    schema.required = required;
  }
  return schema;
}

function deprecatedWithMessage(message) {
  return {
          deprecated: true,
          description: message
        };
}

function string$1(value) {
  return {
          type: "string",
          const: Caml_option.some(value)
        };
}

function integer$1(value) {
  return {
          type: "integer",
          const: Caml_option.some(value)
        };
}

function number$1(value) {
  return {
          type: "number",
          const: Caml_option.some(value)
        };
}

function $$boolean$1(value) {
  return {
          type: "boolean",
          const: Caml_option.some(value)
        };
}

function $$null$1(param) {
  return {
          type: "null"
        };
}

var rawMetadataId = Curry._2(S$ReScriptStruct.Metadata.Id.make, "rescript-json-schema", "raw");

function makeNode(struct) {
  var maybeMetadataRawSchema = S$ReScriptStruct.Metadata.get(struct, rawMetadataId);
  var childStruct = S$ReScriptStruct.classify(struct);
  var node;
  if (typeof childStruct === "number") {
    switch (childStruct) {
      case /* Never */0 :
          node = {
            schema: never(undefined),
            isRequired: true
          };
          break;
      case /* Unknown */1 :
          node = {
            schema: {},
            isRequired: true
          };
          break;
      case /* String */2 :
          node = {
            schema: string(undefined),
            isRequired: true
          };
          break;
      case /* Int */3 :
          node = {
            schema: integer(undefined),
            isRequired: true
          };
          break;
      case /* Float */4 :
          node = {
            schema: number(undefined),
            isRequired: true
          };
          break;
      case /* Bool */5 :
          node = {
            schema: $$boolean(undefined),
            isRequired: true
          };
          break;
      
    }
  } else {
    switch (childStruct.TAG | 0) {
      case /* Literal */0 :
          var value = childStruct._0;
          if (typeof value === "number") {
            switch (value) {
              case /* EmptyNull */0 :
                  node = {
                    schema: $$null$1(undefined),
                    isRequired: true
                  };
                  break;
              case /* EmptyOption */1 :
              case /* NaN */2 :
                  node = raise$2(undefined, struct);
                  break;
              
            }
          } else {
            switch (value.TAG | 0) {
              case /* String */0 :
                  node = {
                    schema: string$1(value._0),
                    isRequired: true
                  };
                  break;
              case /* Int */1 :
                  node = {
                    schema: integer$1(value._0),
                    isRequired: true
                  };
                  break;
              case /* Float */2 :
                  node = {
                    schema: number$1(value._0),
                    isRequired: true
                  };
                  break;
              case /* Bool */3 :
                  node = {
                    schema: $$boolean$1(value._0),
                    isRequired: true
                  };
                  break;
              
            }
          }
          break;
      case /* Option */1 :
          var childNode = makeNode(childStruct._0);
          node = childNode.isRequired ? ({
                schema: childNode.schema,
                isRequired: false
              }) : raise(undefined, /* UnsupportedNestedOptional */0);
          break;
      case /* Null */2 :
          var childNode$1 = makeNode(childStruct._0);
          node = childNode$1.isRequired ? ({
                schema: $$null(childNode$1.schema),
                isRequired: true
              }) : raise$1(undefined, struct);
          break;
      case /* Array */3 :
          var childNode$2 = makeNode(childStruct._0);
          node = childNode$2.isRequired ? ({
                schema: array(childNode$2.schema),
                isRequired: true
              }) : raise$1(undefined, struct);
          break;
      case /* Object */4 :
          var fieldNames = childStruct.fieldNames;
          var fields = childStruct.fields;
          var fieldNodes = fieldNames.map(function (fieldName) {
                var fieldStruct = fields[fieldName];
                try {
                  return makeNode(fieldStruct);
                }
                catch (raw_error){
                  var error = Caml_js_exceptions.internalToOCamlException(raw_error);
                  if (error.RE_EXN_ID === Exception) {
                    throw {
                          RE_EXN_ID: Exception,
                          _1: prependLocation(error._1, fieldName),
                          Error: new Error()
                        };
                  }
                  throw error;
                }
              });
          var properties = {};
          var required = [];
          fieldNodes.forEach(function (fieldNode, idx) {
                var fieldName = fieldNames[idx];
                if (fieldNode.isRequired) {
                  required.push(fieldName);
                }
                properties[fieldName] = fieldNode.schema;
              });
          var match = Curry._1(S$ReScriptStruct.$$Object.UnknownKeys.classify, struct);
          var schema = record(properties, match ? true : false, required);
          node = {
            schema: schema,
            isRequired: true
          };
          break;
      case /* Tuple */5 :
          var items = childStruct._0.map(function (childStruct, idx) {
                var childNode = makeNode(childStruct);
                if (childNode.isRequired) {
                  return childNode.schema;
                } else {
                  return raise$1([idx.toString()], struct);
                }
              });
          node = {
            schema: tuple(items),
            isRequired: true
          };
          break;
      case /* Union */6 :
          var items$1 = childStruct._0.map(function (childStruct) {
                var childNode = makeNode(childStruct);
                if (childNode.isRequired) {
                  return childNode.schema;
                } else {
                  return raise$1(undefined, struct);
                }
              });
          node = {
            schema: union(items$1),
            isRequired: true
          };
          break;
      case /* Dict */7 :
          var childNode$3 = makeNode(childStruct._0);
          node = childNode$3.isRequired ? ({
                schema: dict(childNode$3.schema),
                isRequired: true
              }) : raise$1(undefined, struct);
          break;
      
    }
  }
  var match$1 = S$ReScriptStruct.Deprecated.classify(struct);
  var schema$1 = match$1 !== undefined ? (
      match$1 ? Object.assign(node.schema, deprecatedWithMessage(match$1._0)) : Object.assign(node.schema, {
              deprecated: true
            })
    ) : node.schema;
  var node_isRequired = node.isRequired;
  var node$1 = {
    schema: schema$1,
    isRequired: node_isRequired
  };
  var match$2 = S$ReScriptStruct.Defaulted.classify(struct);
  var node$2;
  if (match$2 !== undefined) {
    var destructingError = S$ReScriptStruct.serializeWith(Caml_option.some(match$2._0), struct);
    node$2 = destructingError.TAG === /* Ok */0 ? ({
          schema: Object.assign(schema$1, $$default(destructingError._0)),
          isRequired: false
        }) : raise(undefined, {
            TAG: /* DefaultDestructingFailed */2,
            destructingErrorMessage: S$ReScriptStruct.$$Error.toString(destructingError._0)
          });
  } else {
    node$2 = node$1;
  }
  var schema$2 = maybeMetadataRawSchema !== undefined ? Object.assign(node$2.schema, maybeMetadataRawSchema) : node$2.schema;
  return {
          schema: schema$2,
          isRequired: node$2.isRequired
        };
}

function make(struct) {
  try {
    var node = makeNode(struct);
    if (node.isRequired) {
      return {
              TAG: /* Ok */0,
              _0: Object.assign(node.schema, schemaDialect(undefined))
            };
    } else {
      return raise(undefined, /* UnsupportedRootOptional */1);
    }
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Exception) {
      return {
              TAG: /* Error */1,
              _0: toString(error._1)
            };
    }
    throw error;
  }
}

function raw(struct, providedRawSchema) {
  var existingRawSchema = S$ReScriptStruct.Metadata.get(struct, rawMetadataId);
  var schema = existingRawSchema !== undefined ? Object.assign({}, existingRawSchema, providedRawSchema) : providedRawSchema;
  return S$ReScriptStruct.Metadata.set(struct, rawMetadataId, schema);
}

function description$1(struct, value) {
  return raw(struct, description(value));
}

exports.Arrayable = Arrayable;
exports.Definition = Definition;
exports.Dependency = Dependency;
exports.make = make;
exports.raw = raw;
exports.description = description$1;
/* rawMetadataId Not a pure module */
