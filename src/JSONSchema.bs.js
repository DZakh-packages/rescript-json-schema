// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Js_dict = require("rescript/lib/js/js_dict.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var JSONSchema7 = require("./JSONSchema7.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var S$RescriptStruct = require("rescript-struct/src/S.bs.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

var Exception = /* @__PURE__ */Caml_exceptions.create("JSONSchema.Error.Exception");

function raise(code) {
  throw {
        RE_EXN_ID: Exception,
        _1: {
          code: code,
          path: []
        },
        Error: new Error()
      };
}

function raise$1(struct) {
  return raise({
              TAG: "UnsupportedOptionalItem",
              _0: S$RescriptStruct.name(struct)
            });
}

function raise$2(struct) {
  return raise({
              TAG: "UnsupportedStruct",
              _0: S$RescriptStruct.name(struct)
            });
}

function pathToText(path) {
  if (path.length !== 0) {
    return path.map(function (pathItem) {
                  return "[\"" + pathItem + "\"]";
                }).join("");
  } else {
    return "root";
  }
}

function prependLocation(error, $$location) {
  error.path = [$$location].concat(error.path);
  return error;
}

function toString(error) {
  var pathText = pathToText(error.path);
  var structName = error.code;
  var reason;
  if (typeof structName !== "object") {
    reason = structName === "UnsupportedNestedOptional" ? "Optional struct is not supported inside the Option struct" : "Optional struct is not supported at root";
  } else {
    switch (structName.TAG) {
      case "UnsupportedOptionalItem" :
          reason = "Optional struct is not supported as " + structName._0 + " item";
          break;
      case "UnsupportedStruct" :
          reason = "The " + structName._0 + " struct is not supported";
          break;
      case "DefaultDestructingFailed" :
          reason = "Couldn't destruct default value. Error: " + structName.destructingErrorMessage;
          break;
      
    }
  }
  return "[ReScript JSON Schema] Failed converting at " + pathText + ". Reason: " + reason;
}

var schemaExtendMetadataId = S$RescriptStruct.Metadata.Id.make("rescript-json-schema", "schemaExtend");

function isOptionalStruct(struct) {
  var match = S$RescriptStruct.classify(struct);
  if (typeof match !== "object" || match.TAG !== "Option") {
    return false;
  } else {
    return true;
  }
}

function makeStructSchema(struct) {
  var schema = {};
  var childStruct = S$RescriptStruct.classify(struct);
  if (typeof childStruct !== "object") {
    switch (childStruct) {
      case "Never" :
          schema.not = {};
          break;
      case "String" :
          schema.type = "string";
          S$RescriptStruct.$$String.refinements(struct).forEach(function (refinement) {
                var match = refinement.kind;
                if (typeof match !== "object") {
                  switch (match) {
                    case "Email" :
                        schema.format = "email";
                        return ;
                    case "Uuid" :
                        schema.format = "uuid";
                        return ;
                    case "Cuid" :
                        return ;
                    case "Url" :
                        schema.format = "uri";
                        return ;
                    case "Datetime" :
                        schema.format = "date-time";
                        return ;
                    
                  }
                } else {
                  switch (match.TAG) {
                    case "Min" :
                        schema.minLength = match.length;
                        return ;
                    case "Max" :
                        schema.maxLength = match.length;
                        return ;
                    case "Length" :
                        var length = match.length;
                        schema.minLength = length;
                        schema.maxLength = length;
                        return ;
                    case "Pattern" :
                        schema.pattern = String(match.re);
                        return ;
                    
                  }
                }
              });
          break;
      case "Int" :
          schema.type = "integer";
          S$RescriptStruct.Int.refinements(struct).forEach(function (refinement) {
                var match = refinement.kind;
                if (typeof match !== "object") {
                  return ;
                } else {
                  if (match.TAG === "Min") {
                    schema.minimum = match.value;
                  } else {
                    schema.maximum = match.value;
                  }
                  return ;
                }
              });
          break;
      case "Float" :
          schema.type = "number";
          S$RescriptStruct.Float.refinements(struct).forEach(function (refinement) {
                var match = refinement.kind;
                if (match.TAG === "Min") {
                  schema.minimum = match.value;
                } else {
                  schema.maximum = match.value;
                }
              });
          break;
      case "Bool" :
          schema.type = "boolean";
          break;
      case "Unknown" :
      case "JSON" :
          break;
      
    }
  } else {
    switch (childStruct.TAG) {
      case "Literal" :
          var value = childStruct._0;
          if (typeof value !== "object") {
            if (value === "Null") {
              schema.type = "null";
            } else {
              raise$2(struct);
            }
          } else {
            switch (value.TAG) {
              case "String" :
                  schema.type = "string";
                  schema.const = value._0;
                  break;
              case "Number" :
                  var value$1 = value._0;
                  var isInt = value$1 % 1 === 0;
                  schema.type = Caml_option.some(isInt ? "integer" : "number");
                  schema.const = value$1;
                  break;
              case "Boolean" :
                  schema.type = "boolean";
                  schema.const = value._0;
                  break;
              default:
                raise$2(struct);
            }
          }
          break;
      case "Option" :
          var childStruct$1 = childStruct._0;
          if (isOptionalStruct(childStruct$1)) {
            raise("UnsupportedNestedOptional");
          }
          var childSchema = makeStructSchema(childStruct$1);
          Object.assign(schema, childSchema);
          var $$default = S$RescriptStruct.$$Option.$$default(struct);
          if ($$default !== undefined) {
            var defaultValue;
            defaultValue = $$default.TAG === "Value" ? $$default._0 : $$default._0(undefined);
            var destructingError = S$RescriptStruct.serializeWith(Caml_option.some(defaultValue), childStruct$1);
            if (destructingError.TAG === "Ok") {
              schema.default = destructingError._0;
            } else {
              raise({
                    TAG: "DefaultDestructingFailed",
                    destructingErrorMessage: S$RescriptStruct.$$Error.message(destructingError._0)
                  });
            }
          }
          break;
      case "Null" :
          schema.anyOf = [
            makeStructSchema(childStruct._0),
            {
              type: "null"
            }
          ];
          break;
      case "Array" :
          var childStruct$2 = childStruct._0;
          if (isOptionalStruct(childStruct$2)) {
            raise$1(struct);
          }
          schema.items = Caml_option.some(makeStructSchema(childStruct$2));
          schema.type = "array";
          S$RescriptStruct.$$Array.refinements(struct).forEach(function (refinement) {
                var match = refinement.kind;
                switch (match.TAG) {
                  case "Min" :
                      schema.minItems = match.length;
                      return ;
                  case "Max" :
                      schema.maxItems = match.length;
                      return ;
                  case "Length" :
                      var length = match.length;
                      schema.maxItems = length;
                      schema.minItems = length;
                      return ;
                  
                }
              });
          break;
      case "Object" :
          var fields = childStruct.fields;
          var properties = {};
          var required = [];
          childStruct.fieldNames.forEach(function (fieldName) {
                var fieldStruct = fields[fieldName];
                var fieldSchema;
                try {
                  fieldSchema = makeStructSchema(fieldStruct);
                }
                catch (raw_error){
                  var error = Caml_js_exceptions.internalToOCamlException(raw_error);
                  if (error.RE_EXN_ID === Exception) {
                    throw {
                          RE_EXN_ID: Exception,
                          _1: prependLocation(error._1, fieldName),
                          Error: new Error()
                        };
                  }
                  throw error;
                }
                if (!isOptionalStruct(fieldStruct)) {
                  required.push(fieldName);
                }
                properties[fieldName] = fieldSchema;
              });
          var additionalProperties;
          additionalProperties = childStruct.unknownKeys === "Strip" ? true : false;
          schema.type = "object";
          schema.properties = Caml_option.some(properties);
          schema.additionalProperties = Caml_option.some(additionalProperties);
          if (required.length !== 0) {
            schema.required = required;
          }
          break;
      case "Tuple" :
          var items = childStruct._0.map(function (childStruct, idx) {
                try {
                  if (isOptionalStruct(childStruct)) {
                    return raise$1(struct);
                  } else {
                    return makeStructSchema(childStruct);
                  }
                }
                catch (raw_error){
                  var error = Caml_js_exceptions.internalToOCamlException(raw_error);
                  if (error.RE_EXN_ID === Exception) {
                    throw {
                          RE_EXN_ID: Exception,
                          _1: prependLocation(error._1, idx.toString()),
                          Error: new Error()
                        };
                  }
                  throw error;
                }
              });
          var itemsNumber = items.length;
          schema.items = Caml_option.some(items);
          schema.type = "array";
          schema.minItems = itemsNumber;
          schema.maxItems = itemsNumber;
          break;
      case "Union" :
          var items$1 = childStruct._0.map(function (childStruct) {
                if (isOptionalStruct(childStruct)) {
                  return raise$1(struct);
                } else {
                  return makeStructSchema(childStruct);
                }
              });
          schema.anyOf = items$1;
          break;
      case "Dict" :
          var childStruct$3 = childStruct._0;
          if (isOptionalStruct(childStruct$3)) {
            raise$1(struct);
          }
          schema.type = "object";
          schema.additionalProperties = Caml_option.some(makeStructSchema(childStruct$3));
          break;
      
    }
  }
  var m = S$RescriptStruct.description(struct);
  if (m !== undefined) {
    schema.description = m;
  }
  var message = S$RescriptStruct.deprecation(struct);
  if (message !== undefined) {
    Object.assign(schema, {
          deprecated: true,
          description: message
        });
  }
  var metadataRawSchema = S$RescriptStruct.Metadata.get(struct, schemaExtendMetadataId);
  if (metadataRawSchema !== undefined) {
    Object.assign(schema, metadataRawSchema);
  }
  return schema;
}

function make(struct) {
  try {
    if (isOptionalStruct(struct)) {
      return raise("UnsupportedRootOptional");
    }
    var schema = makeStructSchema(struct);
    schema.$schema = "http://json-schema.org/draft-07/schema#";
    return {
            TAG: "Ok",
            _0: schema
          };
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Exception) {
      return {
              TAG: "Error",
              _0: toString(error._1)
            };
    }
    throw error;
  }
}

function extend(struct, schema) {
  var existingSchemaExtend = S$RescriptStruct.Metadata.get(struct, schemaExtendMetadataId);
  return S$RescriptStruct.Metadata.set(struct, schemaExtendMetadataId, existingSchemaExtend !== undefined ? Object.assign({}, existingSchemaExtend, schema) : schema);
}

function primitiveToStruct(primitive) {
  return S$RescriptStruct.literal(primitive);
}

function toIntStruct(schema) {
  var minimum = schema.minimum;
  var struct;
  if (minimum !== undefined) {
    struct = S$RescriptStruct.Int.min(S$RescriptStruct.$$int, minimum | 0, undefined);
  } else {
    var exclusiveMinimum = schema.exclusiveMinimum;
    struct = exclusiveMinimum !== undefined ? S$RescriptStruct.Int.min(S$RescriptStruct.$$int, exclusiveMinimum + 1 | 0, undefined) : S$RescriptStruct.$$int;
  }
  var maximum = schema.maximum;
  if (maximum !== undefined) {
    return S$RescriptStruct.Int.max(struct, maximum | 0, undefined);
  }
  var exclusiveMinimum$1 = schema.exclusiveMinimum;
  if (exclusiveMinimum$1 !== undefined) {
    return S$RescriptStruct.Int.max(struct, exclusiveMinimum$1 - 1 | 0, undefined);
  } else {
    return struct;
  }
}

function definitionToDefaultValue(definition) {
  var s = JSONSchema7.Definition.classify(definition);
  if (s.TAG === "Schema") {
    return s._0.default;
  }
  
}

function toStruct(schema) {
  var definitionToStruct = function (definition) {
    var s = JSONSchema7.Definition.classify(definition);
    if (s.TAG === "Schema") {
      return toStruct(s._0);
    } else {
      return S$RescriptStruct.json;
    }
  };
  var type_ = schema.type;
  var struct;
  var exit = 0;
  var exit$1 = 0;
  if (schema.nullable) {
    struct = S$RescriptStruct.$$null(toStruct(Object.assign({}, schema, {
                  nullable: false
                })));
  } else if (type_ !== undefined) {
    var type_$1 = Caml_option.valFromOption(type_);
    if (type_$1 === "object") {
      var properties = schema.properties;
      if (properties !== undefined) {
        var properties$1 = Caml_option.valFromOption(properties);
        var struct$1 = S$RescriptStruct.object(function (s) {
              return Js_dict.fromArray(Js_dict.entries(properties$1).map(function (param) {
                              var property = param[1];
                              var key = param[0];
                              var propertyStruct = definitionToStruct(property);
                              var r = schema.required;
                              var propertyStruct$1;
                              var exit = 0;
                              if (r !== undefined && r.includes(key)) {
                                propertyStruct$1 = propertyStruct;
                              } else {
                                exit = 1;
                              }
                              if (exit === 1) {
                                var defaultValue = definitionToDefaultValue(property);
                                propertyStruct$1 = defaultValue !== undefined ? S$RescriptStruct.$$Option.getOr(S$RescriptStruct.option(propertyStruct), defaultValue) : S$RescriptStruct.option(propertyStruct);
                              }
                              return [
                                      key,
                                      s.f(key, propertyStruct$1)
                                    ];
                            }));
            });
        var additionalProperties = schema.additionalProperties;
        struct = additionalProperties !== undefined && Caml_option.valFromOption(additionalProperties) === false ? S$RescriptStruct.$$Object.strict(struct$1) : struct$1;
      } else {
        var additionalProperties$1 = schema.additionalProperties;
        if (additionalProperties$1 !== undefined) {
          var s = JSONSchema7.Definition.classify(Caml_option.valFromOption(additionalProperties$1));
          struct = s.TAG === "Schema" ? S$RescriptStruct.dict(toStruct(s._0)) : (
              s._0 ? S$RescriptStruct.dict(S$RescriptStruct.json) : S$RescriptStruct.$$Object.strict(S$RescriptStruct.object(function (param) {
                          
                        }))
            );
        } else {
          struct = S$RescriptStruct.object(function (param) {
                
              });
        }
      }
    } else if (type_$1 === "array") {
      var items = schema.items;
      var struct$2;
      if (items !== undefined) {
        var single = JSONSchema7.Arrayable.classify(Caml_option.valFromOption(items));
        if (single.TAG === "Single") {
          struct$2 = S$RescriptStruct.array(definitionToStruct(single._0));
        } else {
          var array = single._0;
          struct$2 = S$RescriptStruct.tuple(function (s) {
                return array.map(function (d, idx) {
                            return s.i(idx, definitionToStruct(d));
                          });
              });
        }
      } else {
        struct$2 = S$RescriptStruct.array(S$RescriptStruct.json);
      }
      var min = schema.minItems;
      var struct$3 = min !== undefined ? S$RescriptStruct.$$Array.min(struct$2, min, undefined) : struct$2;
      var max = schema.maxItems;
      struct = max !== undefined ? S$RescriptStruct.$$Array.max(struct$3, max, undefined) : struct$3;
    } else {
      exit$1 = 2;
    }
  } else {
    exit$1 = 2;
  }
  if (exit$1 === 2) {
    var primitives = schema.enum;
    var definitions = schema.allOf;
    var definitions$1 = schema.anyOf;
    if (definitions$1 !== undefined) {
      var len = definitions$1.length;
      if (len !== 1) {
        struct = len !== 0 ? S$RescriptStruct.union(definitions$1.map(definitionToStruct)) : S$RescriptStruct.json;
      } else {
        var d = definitions$1[0];
        struct = definitionToStruct(d);
      }
    } else if (definitions !== undefined) {
      var len$1 = definitions.length;
      if (len$1 !== 1) {
        struct = len$1 !== 0 ? S$RescriptStruct.refine(S$RescriptStruct.json, (function (s) {
                  return function (data) {
                    definitions.forEach(function (d) {
                          var match = S$RescriptStruct.parseWith(data, definitionToStruct(d));
                          if (match.TAG === "Ok") {
                            return ;
                          } else {
                            return s.fail("Should pass for all schemas of the allOf property.", undefined);
                          }
                        });
                  };
                })) : S$RescriptStruct.json;
      } else {
        var d$1 = definitions[0];
        struct = definitionToStruct(d$1);
      }
    } else {
      var definitions$2 = schema.oneOf;
      if (definitions$2 !== undefined) {
        var len$2 = definitions$2.length;
        if (len$2 !== 1) {
          struct = len$2 !== 0 ? S$RescriptStruct.refine(S$RescriptStruct.json, (function (s) {
                    return function (data) {
                      var hasOneValidRef = {
                        contents: false
                      };
                      definitions$2.forEach(function (d) {
                            var match = S$RescriptStruct.parseWith(data, definitionToStruct(d));
                            if (match.TAG === "Ok") {
                              if (hasOneValidRef.contents) {
                                return s.fail("Should pass single schema according to the oneOf property.", undefined);
                              } else {
                                hasOneValidRef.contents = true;
                                return ;
                              }
                            }
                            
                          });
                      if (!hasOneValidRef.contents) {
                        return s.fail("Should pass at least one schema according to the oneOf property.", undefined);
                      }
                      
                    };
                  })) : S$RescriptStruct.json;
        } else {
          var d$2 = definitions$2[0];
          struct = definitionToStruct(d$2);
        }
      } else {
        var not = schema.not;
        if (not !== undefined) {
          var not$1 = Caml_option.valFromOption(not);
          struct = S$RescriptStruct.refine(S$RescriptStruct.json, (function (s) {
                  return function (data) {
                    var match = S$RescriptStruct.parseWith(data, definitionToStruct(not$1));
                    if (match.TAG === "Ok") {
                      return s.fail("Should NOT be valid against schema in the not property.", undefined);
                    }
                    
                  };
                }));
        } else if (primitives !== undefined) {
          var len$3 = primitives.length;
          if (len$3 !== 1) {
            struct = len$3 !== 0 ? S$RescriptStruct.union(primitives.map(primitiveToStruct)) : S$RescriptStruct.json;
          } else {
            var p = primitives[0];
            struct = S$RescriptStruct.literal(p);
          }
        } else {
          var $$const = schema.const;
          if ($$const !== undefined) {
            struct = S$RescriptStruct.literal($$const);
          } else if (type_ !== undefined) {
            var match = schema.multipleOf;
            var type_$2 = Caml_option.valFromOption(type_);
            var exit$2 = 0;
            var exit$3 = 0;
            var match$1 = schema.format;
            if (Array.isArray(type_$2)) {
              struct = S$RescriptStruct.union(type_$2.map(function (type_) {
                        return toStruct(Object.assign({}, schema, {
                                        type: Caml_option.some(type_)
                                      }));
                      }));
            } else if (type_$2 === "string") {
              var pattern = schema.pattern;
              var struct$4 = pattern !== undefined ? S$RescriptStruct.$$String.pattern(S$RescriptStruct.string, new RegExp(pattern), undefined) : S$RescriptStruct.string;
              var minLength = schema.minLength;
              var struct$5 = minLength !== undefined ? S$RescriptStruct.$$String.min(struct$4, minLength, undefined) : struct$4;
              var maxLength = schema.maxLength;
              var struct$6 = maxLength !== undefined ? S$RescriptStruct.$$String.max(struct$5, maxLength, undefined) : struct$5;
              var match$2 = schema.format;
              if (match$2 !== undefined) {
                switch (match$2) {
                  case "date-time" :
                      struct = S$RescriptStruct.$$String.datetime(struct$6, undefined);
                      break;
                  case "email" :
                      struct = S$RescriptStruct.$$String.email(struct$6, undefined);
                      break;
                  case "uri" :
                      struct = S$RescriptStruct.$$String.url(struct$6, undefined);
                      break;
                  case "uuid" :
                      struct = S$RescriptStruct.$$String.uuid(struct$6, undefined);
                      break;
                  default:
                    struct = struct$6;
                }
              } else {
                struct = struct$6;
              }
            } else if (type_$2 === "integer" || match$1 !== undefined && match$1 === "int64" && type_$2 === "number") {
              struct = toIntStruct(schema);
            } else {
              exit$3 = 4;
            }
            if (exit$3 === 4) {
              if (match !== undefined && !(match !== 1 || type_$2 !== "number")) {
                struct = toIntStruct(schema);
              } else {
                exit$2 = 3;
              }
            }
            if (exit$2 === 3) {
              if (type_$2 === "number") {
                var minimum = schema.minimum;
                var struct$7;
                if (minimum !== undefined) {
                  struct$7 = S$RescriptStruct.Float.min(S$RescriptStruct.$$float, minimum, undefined);
                } else {
                  var exclusiveMinimum = schema.exclusiveMinimum;
                  struct$7 = exclusiveMinimum !== undefined ? S$RescriptStruct.Float.min(S$RescriptStruct.$$float, exclusiveMinimum + 1, undefined) : S$RescriptStruct.$$float;
                }
                var maximum = schema.maximum;
                if (maximum !== undefined) {
                  struct = S$RescriptStruct.Float.max(struct$7, maximum, undefined);
                } else {
                  var exclusiveMinimum$1 = schema.exclusiveMinimum;
                  struct = exclusiveMinimum$1 !== undefined ? S$RescriptStruct.Float.max(struct$7, exclusiveMinimum$1 - 1, undefined) : struct$7;
                }
              } else if (type_$2 === "boolean") {
                struct = S$RescriptStruct.bool;
              } else if (type_$2 === "null") {
                struct = S$RescriptStruct.literal(null);
              } else {
                exit = 1;
              }
            }
            
          } else {
            exit = 1;
          }
        }
      }
    }
  }
  if (exit === 1) {
    var if_ = schema.if;
    if (if_ !== undefined) {
      var then = schema.then;
      if (then !== undefined) {
        var else_ = schema.else;
        if (else_ !== undefined) {
          var ifStruct = definitionToStruct(Caml_option.valFromOption(if_));
          var thenStruct = definitionToStruct(Caml_option.valFromOption(then));
          var elseStruct = definitionToStruct(Caml_option.valFromOption(else_));
          struct = S$RescriptStruct.refine(S$RescriptStruct.json, (function (s) {
                  return function (data) {
                    var match = S$RescriptStruct.parseWith(data, ifStruct);
                    var result;
                    result = match.TAG === "Ok" ? S$RescriptStruct.parseWith(data, thenStruct) : S$RescriptStruct.parseWith(data, elseStruct);
                    if (result.TAG === "Ok") {
                      return ;
                    } else {
                      return s.failWithError(result._0);
                    }
                  };
                }));
        } else {
          struct = S$RescriptStruct.json;
        }
      } else {
        struct = S$RescriptStruct.json;
      }
    } else {
      struct = S$RescriptStruct.json;
    }
  }
  var description = schema.description;
  var struct$8 = description !== undefined ? S$RescriptStruct.describe(struct, description) : struct;
  var description$1 = schema.description;
  if (description$1 !== undefined) {
    return S$RescriptStruct.describe(struct$8, description$1);
  } else {
    return struct$8;
  }
}

var Arrayable = JSONSchema7.Arrayable;

var Mutable = JSONSchema7.Mutable;

var Definition = JSONSchema7.Definition;

var Dependency = JSONSchema7.Dependency;

exports.Arrayable = Arrayable;
exports.Mutable = Mutable;
exports.Definition = Definition;
exports.Dependency = Dependency;
exports.make = make;
exports.extend = extend;
exports.toStruct = toStruct;
/* schemaExtendMetadataId Not a pure module */
